<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>State Management Test</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
      line-height: 1.6;
    }
    h1 {
      color: #2b6cb0;
    }
    h2 {
      color: #319795;
      margin-top: 30px;
    }
    .test-section {
      background-color: #f7fafc;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
    }
    button {
      background-color: #4299e1;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 8px;
      margin-bottom: 8px;
    }
    button:hover {
      background-color: #3182ce;
    }
    pre {
      background-color: #edf2f7;
      padding: 15px;
      border-radius: 4px;
      overflow: auto;
      height: 200px;
      overflow-y: auto;
    }
    .result {
      margin-top: 10px;
      font-weight: bold;
    }
    .result.success {
      color: #38a169;
    }
    .result.warning {
      color: #dd6b20;
    }
    .result.failure {
      color: #e53e3e;
    }
  </style>
</head>
<body>
  <h1>Task 1.4: State Management Foundation Tests</h1>
  <p>This page allows you to test the state management system implemented in Task 1.4.</p>

  <div class="test-section">
    <h2>1. Widget Registry Tests</h2>
    <button id="testWidgetRegistration">Test Widget Registration</button>
    <button id="testWidgetCreation">Test Widget Creation</button>
    <button id="testWidgetUpdate">Test Widget Update</button>
    <button id="testWidgetCapabilities">Test Widget Capabilities</button>
    <div id="widgetRegistryResult" class="result"></div>
    <pre id="widgetRegistryOutput"></pre>
  </div>

  <div class="test-section">
    <h2>2. App Settings Tests</h2>
    <button id="testAppSettings">Test App Settings</button>
    <button id="testAppSettingsUpdate">Test Settings Update</button>
    <button id="testAppSettingsReset">Test Settings Reset</button>
    <div id="appSettingsResult" class="result"></div>
    <pre id="appSettingsOutput"></pre>
  </div>

  <div class="test-section">
    <h2>3. Storage Tests</h2>
    <button id="testLocalStorage">Test Local Storage</button>
    <button id="testIndexedDb">Test IndexedDB</button>
    <button id="testStorageMigration">Test Storage Migration</button>
    <button id="testExportImport">Test Export/Import</button>
    <div id="storageResult" class="result"></div>
    <pre id="storageOutput"></pre>
  </div>

  <div class="test-section">
    <h2>4. Widget Data Tests</h2>
    <button id="testWidgetData">Test Widget Data Storage</button>
    <button id="testWidgetDataTTL">Test Widget Data TTL</button>
    <button id="testWidgetDataRefresh">Test Widget Data Refresh</button>
    <div id="widgetDataResult" class="result"></div>
    <pre id="widgetDataOutput"></pre>
  </div>

  <div class="test-section">
    <h2>5. Integration Tests</h2>
    <button id="testWidgetLifecycle">Test Widget Lifecycle</button>
    <button id="testPersistence">Test State Persistence</button>
    <button id="testCompleteSystem">Test Complete System</button>
    <div id="integrationResult" class="result"></div>
    <pre id="integrationOutput"></pre>
  </div>

  <script>
    // Constants for storage keys (must match those in storage.ts)
    const STORAGE_KEYS = {
      LAYOUT_CONFIG: 'kiosk-app:layout-config',
      THEME_CONFIG: 'kiosk-app:theme-config',
      SETTINGS: 'kiosk-app:settings',
      WIDGETS: 'kiosk-app:widgets',
      APP_STATE: 'kiosk-app:app-state',
    };

    // Log function to add output to the test sections
    function log(sectionId, message, type = '') {
      const outputElement = document.getElementById(`${sectionId}Output`);
      const timestamp = new Date().toLocaleTimeString();
      outputElement.innerHTML += `[${timestamp}] ${message}\n`;
      outputElement.scrollTop = outputElement.scrollHeight;

      if (type) {
        const resultElement = document.getElementById(`${sectionId}Result`);
        resultElement.textContent = message;
        resultElement.className = `result ${type}`;
      }
    }

    // Clear log for a section
    function clearLog(sectionId) {
      const outputElement = document.getElementById(`${sectionId}Output`);
      outputElement.innerHTML = '';
      
      const resultElement = document.getElementById(`${sectionId}Result`);
      resultElement.textContent = '';
      resultElement.className = 'result';
    }

    // Generate a random ID
    function generateId() {
      return `id_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
    }

    // Mock widget types
    const widgetTypes = {
      clock: {
        name: 'Clock Widget',
        description: 'Displays current time and date',
        defaultConfig: {
          type: 'clock',
          title: 'Clock',
          visible: true,
          position: { x: 0, y: 0, width: 2, height: 1 },
          appearance: { showTitle: true },
          clockSettings: {
            showSeconds: true,
            showDate: true,
            use24HourFormat: false,
          }
        }
      },
      weather: {
        name: 'Weather Widget',
        description: 'Displays current weather conditions',
        defaultConfig: {
          type: 'weather',
          title: 'Weather',
          visible: true,
          position: { x: 0, y: 0, width: 2, height: 2 },
          appearance: { showTitle: true },
          weatherSettings: {
            location: 'Oslo, Norway',
            units: 'metric',
            showForecast: true,
            forecastDays: 5,
            showHourlyForecast: true,
          }
        }
      }
    };

    // ===========================
    // 1. Widget Registry Tests
    // ===========================
    
    // Test widget registration
    document.getElementById('testWidgetRegistration').addEventListener('click', () => {
      clearLog('widgetRegistry');
      log('widgetRegistry', 'Testing widget registration...');

      try {
        // Mock widget registry in localStorage
        const registry = {
          version: 1,
          data: {
            types: [
              widgetTypes.clock,
              widgetTypes.weather,
            ],
            instances: []
          },
          timestamp: Date.now()
        };
        
        localStorage.setItem(STORAGE_KEYS.WIDGETS, JSON.stringify(registry));
        log('widgetRegistry', 'Widget types registered successfully.');
        
        // Verify storage
        const storedRegistry = JSON.parse(localStorage.getItem(STORAGE_KEYS.WIDGETS));
        log('widgetRegistry', `Stored ${storedRegistry.data.types.length} widget types.`);
        log('widgetRegistry', 'Widget types: ' + storedRegistry.data.types.map(t => t.name).join(', '));
        
        log('widgetRegistry', 'Widget registration test passed!', 'success');
      } catch (error) {
        log('widgetRegistry', `Error: ${error.message}`, 'failure');
      }
    });
    
    // Test widget creation
    document.getElementById('testWidgetCreation').addEventListener('click', () => {
      clearLog('widgetRegistry');
      log('widgetRegistry', 'Testing widget creation...');

      try {
        // Get registry from localStorage
        const storedData = localStorage.getItem(STORAGE_KEYS.WIDGETS);
        
        if (!storedData) {
          log('widgetRegistry', 'No widget registry found. Please run registration test first.', 'warning');
          return;
        }

        const registry = JSON.parse(storedData);
        
        // Create new widget instances
        const clockId = generateId();
        const weatherId = generateId();
        
        const clockInstance = {
          ...JSON.parse(JSON.stringify(widgetTypes.clock.defaultConfig)),
          id: clockId,
        };
        
        const weatherInstance = {
          ...JSON.parse(JSON.stringify(widgetTypes.weather.defaultConfig)),
          id: weatherId,
          position: { x: 2, y: 0, width: 2, height: 2 },
          weatherSettings: {
            ...widgetTypes.weather.defaultConfig.weatherSettings,
            location: 'Bergen, Norway'
          }
        };
        
        registry.data.instances = [clockInstance, weatherInstance];
        
        // Save updated registry
        localStorage.setItem(STORAGE_KEYS.WIDGETS, JSON.stringify(registry));
        
        log('widgetRegistry', `Created clock widget with ID: ${clockId}`);
        log('widgetRegistry', `Created weather widget with ID: ${weatherId}`);
        log('widgetRegistry', 'Widget instances created successfully.', 'success');
      } catch (error) {
        log('widgetRegistry', `Error: ${error.message}`, 'failure');
      }
    });
    
    // Test widget update
    document.getElementById('testWidgetUpdate').addEventListener('click', () => {
      clearLog('widgetRegistry');
      log('widgetRegistry', 'Testing widget updates...');

      try {
        // Get registry from localStorage
        const storedData = localStorage.getItem(STORAGE_KEYS.WIDGETS);
        
        if (!storedData) {
          log('widgetRegistry', 'No widget registry found. Please run creation test first.', 'warning');
          return;
        }

        const registry = JSON.parse(storedData);
        
        if (!registry.data.instances || registry.data.instances.length === 0) {
          log('widgetRegistry', 'No widget instances found. Please run creation test first.', 'warning');
          return;
        }
        
        // Update first widget instance
        const firstWidget = registry.data.instances[0];
        const originalTitle = firstWidget.title;
        
        log('widgetRegistry', `Updating widget "${originalTitle}" (ID: ${firstWidget.id})`);
        
        // Update title and position
        firstWidget.title = `${originalTitle} - Updated`;
        firstWidget.position = { 
          ...firstWidget.position,
          width: firstWidget.position.width + 1,
          height: firstWidget.position.height + 1
        };
        
        // Save updated registry
        localStorage.setItem(STORAGE_KEYS.WIDGETS, JSON.stringify(registry));
        
        // Verify update
        const updatedRegistry = JSON.parse(localStorage.getItem(STORAGE_KEYS.WIDGETS));
        const updatedWidget = updatedRegistry.data.instances[0];
        
        log('widgetRegistry', `Updated title: ${updatedWidget.title}`);
        log('widgetRegistry', `Updated size: ${updatedWidget.position.width}Ã—${updatedWidget.position.height}`);
        log('widgetRegistry', 'Widget update test passed!', 'success');
      } catch (error) {
        log('widgetRegistry', `Error: ${error.message}`, 'failure');
      }
    });
    
    // Test widget capabilities
    document.getElementById('testWidgetCapabilities').addEventListener('click', () => {
      clearLog('widgetRegistry');
      log('widgetRegistry', 'Testing widget capabilities...');

      try {
        // Define capabilities
        const capabilities = {
          clock: {
            resizable: true,
            movable: true,
            configurable: true,
            refreshable: true
          },
          weather: {
            resizable: true,
            movable: true,
            configurable: true,
            refreshable: true
          }
        };
        
        log('widgetRegistry', 'Setting widget capabilities...');
        localStorage.setItem('kiosk-app:widget-capabilities', JSON.stringify({
          version: 1,
          data: capabilities,
          timestamp: Date.now()
        }));
        
        // Get registry
        const storedData = localStorage.getItem(STORAGE_KEYS.WIDGETS);
        
        if (!storedData) {
          log('widgetRegistry', 'No widget registry found. Please run creation test first.', 'warning');
          return;
        }

        const registry = JSON.parse(storedData);
        
        // Add capabilities reference to widget instances
        if (registry.data.instances && registry.data.instances.length > 0) {
          registry.data.instances.forEach(instance => {
            log('widgetRegistry', `Setting capabilities for widget: ${instance.title}`);
            const widgetType = instance.type;
            const typeCapabilities = capabilities[widgetType];
            
            if (typeCapabilities) {
              log('widgetRegistry', `Capabilities: ${JSON.stringify(typeCapabilities)}`);
            } else {
              log('widgetRegistry', `No capabilities defined for type: ${widgetType}`, 'warning');
            }
          });
          
          log('widgetRegistry', 'Widget capabilities test passed!', 'success');
        } else {
          log('widgetRegistry', 'No widget instances found. Please run creation test first.', 'warning');
        }
      } catch (error) {
        log('widgetRegistry', `Error: ${error.message}`, 'failure');
      }
    });

    // ===========================
    // 2. App Settings Tests
    // ===========================
    
    // Test app settings
    document.getElementById('testAppSettings').addEventListener('click', () => {
      clearLog('appSettings');
      log('appSettings', 'Testing app settings...');

      try {
        // Default settings
        const defaultSettings = {
          general: {
            appName: 'Kiosk App',
            startupMode: 'normal',
            language: 'en',
            autoSave: true,
            autoRefresh: true,
            refreshInterval: 900000,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC',
          },
          display: {
            fullscreen: false,
            showClock: true,
            showControls: true,
            controlsTimeout: 3000,
            controlsPosition: 'bottom',
            screenSaver: {
              enabled: true,
              timeout: 1800000,
              type: 'photos',
            },
          },
          network: {
            offlineMode: false,
            cacheStrategy: 'network-first',
            connectionCheck: {
              enabled: true,
              interval: 60000,
              url: 'https://www.google.com',
            },
          },
          privacy: {
            allowCookies: true,
            allowTracking: false,
            allowErrorReporting: true,
            storeCredentials: false,
          },
          advanced: {
            debugMode: false,
            experimentalFeatures: false,
            widgetRefreshIndividually: true,
            useHardwareAcceleration: true,
            logLevel: 'error',
          },
        };
        
        log('appSettings', 'Saving default app settings...');
        localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify({
          version: 1,
          data: defaultSettings,
          timestamp: Date.now()
        }));
        
        // Verify
        const storedSettings = JSON.parse(localStorage.getItem(STORAGE_KEYS.SETTINGS));
        log('appSettings', 'Stored settings version: ' + storedSettings.version);
        log('appSettings', 'App name: ' + storedSettings.data.general.appName);
        log('appSettings', 'Language: ' + storedSettings.data.general.language);
        log('appSettings', 'Timezone: ' + storedSettings.data.general.timezone);
        
        log('appSettings', 'App settings test passed!', 'success');
      } catch (error) {
        log('appSettings', `Error: ${error.message}`, 'failure');
      }
    });
    
    // Test settings update
    document.getElementById('testAppSettingsUpdate').addEventListener('click', () => {
      clearLog('appSettings');
      log('appSettings', 'Testing app settings updates...');

      try {
        // Get current settings
        const storedData = localStorage.getItem(STORAGE_KEYS.SETTINGS);
        
        if (!storedData) {
          log('appSettings', 'No settings found. Please run settings test first.', 'warning');
          return;
        }

        const settingsObj = JSON.parse(storedData);
        const settings = settingsObj.data;
        
        // Make changes
        log('appSettings', 'Updating app settings...');
        
        settings.general.appName = 'My Custom Kiosk';
        settings.general.language = 'no';
        settings.display.fullscreen = true;
        settings.display.screenSaver.timeout = 3600000; // 1 hour
        settings.advanced.debugMode = true;
        
        // Save updated settings
        settingsObj.data = settings;
        settingsObj.timestamp = Date.now();
        
        localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(settingsObj));
        
        // Verify updates
        const updatedSettings = JSON.parse(localStorage.getItem(STORAGE_KEYS.SETTINGS));
        log('appSettings', 'Updated app name: ' + updatedSettings.data.general.appName);
        log('appSettings', 'Updated language: ' + updatedSettings.data.general.language);
        log('appSettings', 'Updated fullscreen mode: ' + updatedSettings.data.display.fullscreen);
        log('appSettings', 'Updated screensaver timeout: ' + updatedSettings.data.display.screenSaver.timeout + 'ms');
        log('appSettings', 'Updated debug mode: ' + updatedSettings.data.advanced.debugMode);
        
        log('appSettings', 'App settings update test passed!', 'success');
      } catch (error) {
        log('appSettings', `Error: ${error.message}`, 'failure');
      }
    });
    
    // Test settings reset
    document.getElementById('testAppSettingsReset').addEventListener('click', () => {
      clearLog('appSettings');
      log('appSettings', 'Testing app settings reset...');

      try {
        // Default settings
        const defaultSettings = {
          general: {
            appName: 'Kiosk App',
            startupMode: 'normal',
            language: 'en',
            autoSave: true,
            autoRefresh: true,
            refreshInterval: 900000,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC',
          },
          display: {
            fullscreen: false,
            showClock: true,
            showControls: true,
            controlsTimeout: 3000,
            controlsPosition: 'bottom',
            screenSaver: {
              enabled: true,
              timeout: 1800000,
              type: 'photos',
            },
          },
          network: {
            offlineMode: false,
            cacheStrategy: 'network-first',
            connectionCheck: {
              enabled: true,
              interval: 60000,
              url: 'https://www.google.com',
            },
          },
          privacy: {
            allowCookies: true,
            allowTracking: false,
            allowErrorReporting: true,
            storeCredentials: false,
          },
          advanced: {
            debugMode: false,
            experimentalFeatures: false,
            widgetRefreshIndividually: true,
            useHardwareAcceleration: true,
            logLevel: 'error',
          },
        };
        
        log('appSettings', 'Resetting app settings to defaults...');
        
        // Get current settings to display changes
        const oldSettings = JSON.parse(localStorage.getItem(STORAGE_KEYS.SETTINGS) || '{}');
        if (oldSettings.data) {
          log('appSettings', 'Old app name: ' + oldSettings.data.general?.appName);
          log('appSettings', 'Old language: ' + oldSettings.data.general?.language);
        }
        
        // Save default settings
        localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify({
          version: 1,
          data: defaultSettings,
          timestamp: Date.now()
        }));
        
        // Verify reset
        const resetSettings = JSON.parse(localStorage.getItem(STORAGE_KEYS.SETTINGS));
        log('appSettings', 'Reset app name: ' + resetSettings.data.general.appName);
        log('appSettings', 'Reset language: ' + resetSettings.data.general.language);
        
        log('appSettings', 'App settings reset test passed!', 'success');
      } catch (error) {
        log('appSettings', `Error: ${error.message}`, 'failure');
      }
    });

    // ===========================
    // 3. Storage Tests
    // ===========================
    
    // Test local storage
    document.getElementById('testLocalStorage').addEventListener('click', () => {
      clearLog('storage');
      log('storage', 'Testing localStorage...');

      try {
        // Test basic operations
        const testKey = 'storage-test-key';
        const testData = {
          name: 'Test Data',
          items: [1, 2, 3, 4, 5],
          nestedData: {
            key1: 'value1',
            key2: 'value2'
          },
          timestamp: Date.now()
        };
        
        // Save with versioning
        log('storage', 'Saving test data to localStorage...');
        localStorage.setItem(testKey, JSON.stringify({
          version: 1,
          data: testData,
          timestamp: Date.now()
        }));
        
        // Retrieve
        const storedData = JSON.parse(localStorage.getItem(testKey));
        log('storage', 'Retrieved test data from localStorage.');
        log('storage', 'Version: ' + storedData.version);
        log('storage', 'Data name: ' + storedData.data.name);
        log('storage', 'Items count: ' + storedData.data.items.length);
        
        // Update
        log('storage', 'Updating test data...');
        storedData.data.name = 'Updated Test Data';
        storedData.data.items.push(6);
        storedData.version = 2;
        storedData.timestamp = Date.now();
        
        localStorage.setItem(testKey, JSON.stringify(storedData));
        
        // Verify update
        const updatedData = JSON.parse(localStorage.getItem(testKey));
        log('storage', 'Updated version: ' + updatedData.version);
        log('storage', 'Updated name: ' + updatedData.data.name);
        log('storage', 'Updated items count: ' + updatedData.data.items.length);
        
        // Remove
        log('storage', 'Removing test data...');
        localStorage.removeItem(testKey);
        
        const afterRemoval = localStorage.getItem(testKey);
        if (afterRemoval === null) {
          log('storage', 'Test data successfully removed.');
        } else {
          log('storage', 'Failed to remove test data!', 'warning');
        }
        
        log('storage', 'Local storage test passed!', 'success');
      } catch (error) {
        log('storage', `Error: ${error.message}`, 'failure');
      }
    });
    
    // Test IndexedDB
    document.getElementById('testIndexedDb').addEventListener('click', () => {
      clearLog('storage');
      log('storage', 'Testing IndexedDB...');
      
      try {
        // Check IndexedDB support
        if (!window.indexedDB) {
          log('storage', 'IndexedDB is not supported in this browser.', 'warning');
          return;
        }
        
        log('storage', 'Opening test database...');
        const dbRequest = indexedDB.open('kiosk-app-test', 1);
        
        dbRequest.onerror = (event) => {
          log('storage', 'Error opening IndexedDB: ' + event.target.error.message, 'failure');
        };
        
        dbRequest.onupgradeneeded = (event) => {
          log('storage', 'Creating test object store...');
          const db = event.target.result;
          
          // Create object store
          if (!db.objectStoreNames.contains('test-store')) {
            const objectStore = db.createObjectStore('test-store', { keyPath: 'id' });
            objectStore.createIndex('updatedAt', 'updatedAt', { unique: false });
            log('storage', 'Test object store created.');
          }
        };
        
        dbRequest.onsuccess = (event) => {
          const db = event.target.result;
          log('storage', 'Database opened successfully.');
          
          // Test data
          const testData = {
            id: 'test-item-' + Date.now(),
            name: 'Test Item',
            description: 'This is a test item for IndexedDB',
            tags: ['test', 'indexeddb', 'storage'],
            metadata: {
              creator: 'State Management Test',
              importance: 'high'
            },
            updatedAt: Date.now()
          };
          
          // Add data
          log('storage', 'Adding test data to IndexedDB...');
          const transaction = db.transaction(['test-store'], 'readwrite');
          
          transaction.onerror = (event) => {
            log('storage', 'Transaction error: ' + event.target.error.message, 'failure');
          };
          
          const objectStore = transaction.objectStore('test-store');
          const addRequest = objectStore.add(testData);
          
          addRequest.onsuccess = () => {
            log('storage', 'Test data added successfully.');
            
            // Read data back
            const readTransaction = db.transaction(['test-store'], 'readonly');
            const readStore = readTransaction.objectStore('test-store');
            const getRequest = readStore.get(testData.id);
            
            getRequest.onsuccess = () => {
              const retrievedData = getRequest.result;
              log('storage', 'Retrieved test data:');
              log('storage', ' - ID: ' + retrievedData.id);
              log('storage', ' - Name: ' + retrievedData.name);
              log('storage', ' - Tags: ' + retrievedData.tags.join(', '));
              
              // Update data
              log('storage', 'Updating test data...');
              retrievedData.name = 'Updated Test Item';
              retrievedData.tags.push('updated');
              retrievedData.updatedAt = Date.now();
              
              const updateTransaction = db.transaction(['test-store'], 'readwrite');
              const updateStore = updateTransaction.objectStore('test-store');
              const updateRequest = updateStore.put(retrievedData);
              
              updateRequest.onsuccess = () => {
                log('storage', 'Test data updated successfully.');
                
                // Delete data
                log('storage', 'Deleting test data...');
                const deleteTransaction = db.transaction(['test-store'], 'readwrite');
                const deleteStore = deleteTransaction.objectStore('test-store');
                const deleteRequest = deleteStore.delete(testData.id);
                
                deleteRequest.onsuccess = () => {
                  log('storage', 'Test data deleted successfully.');
                  log('storage', 'Closing database...');
                  db.close();
                  log('storage', 'IndexedDB test passed!', 'success');
                };
                
                deleteRequest.onerror = (event) => {
                  log('storage', 'Error deleting data: ' + event.target.error.message, 'failure');
                };
              };
              
              updateRequest.onerror = (event) => {
                log('storage', 'Error updating data: ' + event.target.error.message, 'failure');
              };
            };
            
            getRequest.onerror = (event) => {
              log('storage', 'Error retrieving data: ' + event.target.error.message, 'failure');
            };
          };
          
          addRequest.onerror = (event) => {
            log('storage', 'Error adding data: ' + event.target.error.message, 'failure');
          };
        };
      } catch (error) {
        log('storage', `Error: ${error.message}`, 'failure');
      }
    });
    
    // Test storage migration
    document.getElementById('testStorageMigration').addEventListener('click', () => {
      clearLog('storage');
      log('storage', 'Testing storage migration...');

      try {
        const migrationTestKey = 'migration-test-key';
        
        // Version 1 schema
        const v1Data = {
          name: 'Test User',
          preferences: {
            theme: 'dark',
            notifications: true
          }
        };
        
        // Save v1 data
        log('storage', 'Saving version 1 data...');
        localStorage.setItem(migrationTestKey, JSON.stringify({
          version: 1,
          data: v1Data,
          timestamp: Date.now()
        }));
        
        // Simulate migration to version 2
        log('storage', 'Migrating to version 2...');
        
        const storedData = JSON.parse(localStorage.getItem(migrationTestKey));
        
        // Migration function: v1 -> v2
        const migrateV1ToV2 = (oldData) => {
          return {
            name: oldData.name,
            email: 'user@example.com', // New field in v2
            preferences: {
              ...oldData.preferences,
              language: 'en' // New preference in v2
            }
          };
        };
        
        // Apply migration
        const v2Data = migrateV1ToV2(storedData.data);
        
        // Save v2 data
        localStorage.setItem(migrationTestKey, JSON.stringify({
          version: 2,
          data: v2Data,
          timestamp: Date.now()
        }));
        
        // Verify migration
        const migratedData = JSON.parse(localStorage.getItem(migrationTestKey));
        
        log('storage', 'Migrated data:');
        log('storage', ' - Version: ' + migratedData.version);
        log('storage', ' - Name: ' + migratedData.data.name);
        log('storage', ' - Email: ' + migratedData.data.email);
        log('storage', ' - Theme: ' + migratedData.data.preferences.theme);
        log('storage', ' - Language: ' + migratedData.data.preferences.language);
        
        // Clean up
        localStorage.removeItem(migrationTestKey);
        
        log('storage', 'Storage migration test passed!', 'success');
      } catch (error) {
        log('storage', `Error: ${error.message}`, 'failure');
      }
    });
    
    // Test export/import
    document.getElementById('testExportImport').addEventListener('click', () => {
      clearLog('storage');
      log('storage', 'Testing export/import functionality...');

      try {
        // Set up test data
        const testData = {
          settings: {
            version: 1,
            data: {
              general: {
                appName: 'Export Test App',
                language: 'en'
              },
              display: {
                theme: 'dark',
                fontSize: 16
              }
            },
            timestamp: Date.now()
          },
          widgets: {
            version: 1,
            data: {
              types: [
                { name: 'Test Widget', type: 'test' }
              ],
              instances: [
                {
                  id: 'widget1',
                  type: 'test',
                  title: 'My Test Widget',
                  position: { x: 0, y: 0, width: 2, height: 2 }
                }
              ]
            },
            timestamp: Date.now()
          }
        };
        
        // Save test data
        log('storage', 'Saving test data for export...');
        localStorage.setItem('export-test-settings', JSON.stringify(testData.settings));
        localStorage.setItem('export-test-widgets', JSON.stringify(testData.widgets));
        
        // Export data
        log('storage', 'Exporting data...');
        const exportData = {
          'export-test-settings': JSON.parse(localStorage.getItem('export-test-settings')),
          'export-test-widgets': JSON.parse(localStorage.getItem('export-test-widgets'))
        };
        
        const exportString = JSON.stringify(exportData);
        log('storage', `Exported data size: ${exportString.length} bytes`);
        
        // Clear data to simulate import to a new system
        log('storage', 'Clearing data before import...');
        localStorage.removeItem('export-test-settings');
        localStorage.removeItem('export-test-widgets');
        
        // Verify clear
        const afterClear1 = localStorage.getItem('export-test-settings');
        const afterClear2 = localStorage.getItem('export-test-widgets');
        
        if (afterClear1 === null && afterClear2 === null) {
          log('storage', 'Data cleared successfully.');
        } else {
          log('storage', 'Failed to clear data!', 'warning');
        }
        
        // Import data
        log('storage', 'Importing data...');
        const importData = JSON.parse(exportString);
        
        Object.entries(importData).forEach(([key, value]) => {
          localStorage.setItem(key, JSON.stringify(value));
        });
        
        // Verify import
        const importedSettings = JSON.parse(localStorage.getItem('export-test-settings'));
        const importedWidgets = JSON.parse(localStorage.getItem('export-test-widgets'));
        
        log('storage', 'Imported settings:');
        log('storage', ' - App name: ' + importedSettings.data.general.appName);
        log('storage', ' - Theme: ' + importedSettings.data.display.theme);
        
        log('storage', 'Imported widgets:');
        log('storage', ' - Widget count: ' + importedWidgets.data.instances.length);
        log('storage', ' - First widget title: ' + importedWidgets.data.instances[0].title);
        
        // Clean up
        localStorage.removeItem('export-test-settings');
        localStorage.removeItem('export-test-widgets');
        
        log('storage', 'Export/import test passed!', 'success');
      } catch (error) {
        log('storage', `Error: ${error.message}`, 'failure');
      }
    });

    // ===========================
    // 4. Widget Data Tests
    // ===========================
    
    // Test widget data storage
    document.getElementById('testWidgetData').addEventListener('click', () => {
      clearLog('widgetData');
      log('widgetData', 'Testing widget data storage...');

      try {
        // Use IndexedDB for widget data
        log('widgetData', 'Opening widget data database...');
        const dbRequest = indexedDB.open('kiosk-app-widget-data-test', 1);
        
        dbRequest.onerror = (event) => {
          log('widgetData', 'Error opening IndexedDB: ' + event.target.error.message, 'failure');
        };
        
        dbRequest.onupgradeneeded = (event) => {
          log('widgetData', 'Creating widget data store...');
          const db = event.target.result;
          
          if (!db.objectStoreNames.contains('data')) {
            const objectStore = db.createObjectStore('data', { keyPath: 'id' });
            objectStore.createIndex('widgetId', 'widgetId', { unique: false });
            objectStore.createIndex('type', 'type', { unique: false });
            objectStore.createIndex('updatedAt', 'updatedAt', { unique: false });
            log('widgetData', 'Widget data store created.');
          }
        };
        
        dbRequest.onsuccess = (event) => {
          const db = event.target.result;
          log('widgetData', 'Database opened successfully.');
          
          // Test widget data
          const weatherWidgetId = 'weather-widget-1';
          const weatherWidgetData = {
            id: `widget_data_${weatherWidgetId}`,
            widgetId: weatherWidgetId,
            type: 'weather',
            data: {
              current: {
                temperature: 22,
                condition: 'Sunny',
                humidity: 45,
                windSpeed: 10
              },
              forecast: [
                { day: 'Monday', high: 24, low: 18, condition: 'Sunny' },
                { day: 'Tuesday', high: 26, low: 17, condition: 'Partly Cloudy' },
                { day: 'Wednesday', high: 20, low: 15, condition: 'Rain' }
              ],
              location: {
                name: 'Oslo',
                country: 'Norway',
                coordinates: { lat: 59.9139, lon: 10.7522 }
              }
            },
            updatedAt: Date.now()
          };
          
          // Add widget data
          log('widgetData', 'Adding widget data...');
          const transaction = db.transaction(['data'], 'readwrite');
          
          transaction.onerror = (event) => {
            log('widgetData', 'Transaction error: ' + event.target.error.message, 'failure');
          };
          
          const objectStore = transaction.objectStore('data');
          const addRequest = objectStore.add(weatherWidgetData);
          
          addRequest.onsuccess = () => {
            log('widgetData', 'Widget data added successfully.');
            
            // Read data back
            const readTransaction = db.transaction(['data'], 'readonly');
            const readStore = readTransaction.objectStore('data');
            const getRequest = readStore.get(weatherWidgetData.id);
            
            getRequest.onsuccess = () => {
              const retrievedData = getRequest.result;
              log('widgetData', 'Retrieved widget data:');
              log('widgetData', ' - Widget ID: ' + retrievedData.widgetId);
              log('widgetData', ' - Type: ' + retrievedData.type);
              log('widgetData', ' - Current temperature: ' + retrievedData.data.current.temperature);
              log('widgetData', ' - Location: ' + retrievedData.data.location.name);
              log('widgetData', ' - Forecast days: ' + retrievedData.data.forecast.length);
              
              // Update widget data
              log('widgetData', 'Updating widget data...');
              retrievedData.data.current.temperature = 25;
              retrievedData.data.current.condition = 'Clear';
              retrievedData.updatedAt = Date.now();
              
              const updateTransaction = db.transaction(['data'], 'readwrite');
              const updateStore = updateTransaction.objectStore('data');
              const updateRequest = updateStore.put(retrievedData);
              
              updateRequest.onsuccess = () => {
                log('widgetData', 'Widget data updated successfully.');
                
                // Verify update
                const verifyTransaction = db.transaction(['data'], 'readonly');
                const verifyStore = verifyTransaction.objectStore('data');
                const verifyRequest = verifyStore.get(weatherWidgetData.id);
                
                verifyRequest.onsuccess = () => {
                  const verifiedData = verifyRequest.result;
                  log('widgetData', 'Verified updated data:');
                  log('widgetData', ' - New temperature: ' + verifiedData.data.current.temperature);
                  log('widgetData', ' - New condition: ' + verifiedData.data.current.condition);
                  
                  // Clean up
                  const deleteTransaction = db.transaction(['data'], 'readwrite');
                  const deleteStore = deleteTransaction.objectStore('data');
                  const deleteRequest = deleteStore.delete(weatherWidgetData.id);
                  
                  deleteRequest.onsuccess = () => {
                    log('widgetData', 'Test data cleaned up successfully.');
                    db.close();
                    log('widgetData', 'Widget data storage test passed!', 'success');
                  };
                };
              };
            };
          };
        };
      } catch (error) {
        log('widgetData', `Error: ${error.message}`, 'failure');
      }
    });
    
    // Test widget data TTL
    document.getElementById('testWidgetDataTTL').addEventListener('click', () => {
      clearLog('widgetData');
      log('widgetData', 'Testing widget data TTL (Time To Live)...');

      try {
        // Use IndexedDB for widget data
        log('widgetData', 'Opening widget data database...');
        const dbRequest = indexedDB.open('kiosk-app-widget-data-test', 1);
        
        dbRequest.onsuccess = (event) => {
          const db = event.target.result;
          log('widgetData', 'Database opened successfully.');
          
          // Test widget data with TTL
          const clockWidgetId = 'clock-widget-1';
          const clockWidgetData = {
            id: `widget_data_${clockWidgetId}`,
            widgetId: clockWidgetId,
            type: 'clock',
            data: {
              time: new Date().toISOString(),
              timezone: 'Europe/Oslo'
            },
            updatedAt: Date.now(),
            ttl: 5000 // 5 seconds TTL
          };
          
          // Add widget data
          log('widgetData', 'Adding widget data with 5 second TTL...');
          const transaction = db.transaction(['data'], 'readwrite');
          const objectStore = transaction.objectStore('data');
          const addRequest = objectStore.add(clockWidgetData);
          
          addRequest.onsuccess = () => {
            log('widgetData', 'Widget data added successfully.');
            log('widgetData', 'Added at: ' + new Date().toLocaleTimeString());
            log('widgetData', 'Will expire at: ' + new Date(clockWidgetData.updatedAt + clockWidgetData.ttl).toLocaleTimeString());
            
            // Check immediately
            const checkNow = db.transaction(['data'], 'readonly');
            const checkStore = checkNow.objectStore('data');
            const checkRequest = checkStore.get(clockWidgetData.id);
            
            checkRequest.onsuccess = () => {
              const data = checkRequest.result;
              if (data) {
                log('widgetData', 'Data exists immediately after adding (as expected).');
                
                // Check if data has expired
                const now = Date.now();
                const expiryTime = data.updatedAt + data.ttl;
                const hasExpired = now > expiryTime;
                
                log('widgetData', `Data expiry check: ${hasExpired ? 'Expired' : 'Not expired'} (should be Not expired)`);
                
                // Check again after TTL
                log('widgetData', 'Waiting for TTL to expire...');
                
                setTimeout(() => {
                  // Check after TTL
                  const checkAfterTTL = db.transaction(['data'], 'readonly');
                  const checkStoreTTL = checkAfterTTL.objectStore('data');
                  const checkRequestTTL = checkStoreTTL.get(clockWidgetData.id);
                  
                  checkRequestTTL.onsuccess = () => {
                    const dataAfterTTL = checkRequestTTL.result;
                    
                    if (dataAfterTTL) {
                      log('widgetData', 'Data still exists after TTL.', 'warning');
                      log('widgetData', 'Current time: ' + new Date().toLocaleTimeString());
                      log('widgetData', 'Expiry time: ' + new Date(dataAfterTTL.updatedAt + dataAfterTTL.ttl).toLocaleTimeString());
                      
                      // In a real implementation, we would check the TTL and delete if expired
                      const now = Date.now();
                      const expiryTime = dataAfterTTL.updatedAt + dataAfterTTL.ttl;
                      const hasExpired = now > expiryTime;
                      
                      if (hasExpired) {
                        log('widgetData', 'Data has expired, deleting...');
                        
                        const deleteTransaction = db.transaction(['data'], 'readwrite');
                        const deleteStore = deleteTransaction.objectStore('data');
                        const deleteRequest = deleteStore.delete(clockWidgetData.id);
                        
                        deleteRequest.onsuccess = () => {
                          log('widgetData', 'Expired data deleted successfully.');
                          log('widgetData', 'Widget data TTL test completed with manual cleanup.', 'success');
                          db.close();
                        };
                      } else {
                        log('widgetData', 'Data unexpectedly has not expired yet.', 'warning');
                        db.close();
                      }
                    } else {
                      log('widgetData', 'Data has been automatically removed after TTL.');
                      log('widgetData', 'Widget data TTL test passed!', 'success');
                      db.close();
                    }
                  };
                }, 6000); // Wait 6 seconds (1 second after TTL)
              } else {
                log('widgetData', 'Data not found immediately after adding!', 'failure');
                db.close();
              }
            };
          };
        };
        
        dbRequest.onerror = (event) => {
          log('widgetData', 'Error opening IndexedDB: ' + event.target.error.message, 'failure');
        };
      } catch (error) {
        log('widgetData', `Error: ${error.message}`, 'failure');
      }
    });
    
    // Test widget data refresh
    document.getElementById('testWidgetDataRefresh').addEventListener('click', () => {
      clearLog('widgetData');
      log('widgetData', 'Testing widget data refresh...');

      try {
        // Use IndexedDB for widget data
        log('widgetData', 'Opening widget data database...');
        const dbRequest = indexedDB.open('kiosk-app-widget-data-test', 1);
        
        dbRequest.onsuccess = (event) => {
          const db = event.target.result;
          log('widgetData', 'Database opened successfully.');
          
          // Create or update widget data for testing refresh
          const testWidgetId = 'refresh-test-widget';
          const initialData = {
            id: `widget_data_${testWidgetId}`,
            widgetId: testWidgetId,
            type: 'test',
            data: {
              counter: 1,
              lastUpdated: new Date().toISOString(),
              message: 'Initial data'
            },
            updatedAt: Date.now()
          };
          
          // Add/update widget data
          log('widgetData', 'Adding initial widget data...');
          const transaction = db.transaction(['data'], 'readwrite');
          const objectStore = transaction.objectStore('data');
          const addRequest = objectStore.put(initialData);
          
          addRequest.onsuccess = () => {
            log('widgetData', 'Initial widget data saved.');
            log('widgetData', ' - Counter: ' + initialData.data.counter);
            log('widgetData', ' - Message: ' + initialData.data.message);
            log('widgetData', ' - Last Updated: ' + initialData.data.lastUpdated);
            
            // Simulate a refresh operation
            log('widgetData', 'Simulating data refresh...');
            
            // In a real system, this would fetch new data from an API
            // For this test, we'll just update the existing data
            setTimeout(() => {
              const refreshTransaction = db.transaction(['data'], 'readwrite');
              const refreshStore = refreshTransaction.objectStore('data');
              const getRequest = refreshStore.get(initialData.id);
              
              getRequest.onsuccess = () => {
                const currentData = getRequest.result;
                
                if (currentData) {
                  // Update the data as if it was refreshed
                  const refreshedData = {
                    ...currentData,
                    data: {
                      counter: currentData.data.counter + 1,
                      lastUpdated: new Date().toISOString(),
                      message: 'Data refreshed at ' + new Date().toLocaleTimeString()
                    },
                    updatedAt: Date.now()
                  };
                  
                  const updateRequest = refreshStore.put(refreshedData);
                  
                  updateRequest.onsuccess = () => {
                    log('widgetData', 'Widget data refreshed successfully.');
                    
                    // Verify refresh
                    const verifyTransaction = db.transaction(['data'], 'readonly');
                    const verifyStore = verifyTransaction.objectStore('data');
                    const verifyRequest = verifyStore.get(initialData.id);
                    
                    verifyRequest.onsuccess = () => {
                      const verifiedData = verifyRequest.result;
                      log('widgetData', 'Verified refreshed data:');
                      log('widgetData', ' - Counter: ' + verifiedData.data.counter);
                      log('widgetData', ' - Message: ' + verifiedData.data.message);
                      log('widgetData', ' - Last Updated: ' + verifiedData.data.lastUpdated);
                      
                      // Clean up
                      const deleteTransaction = db.transaction(['data'], 'readwrite');
                      const deleteStore = deleteTransaction.objectStore('data');
                      const deleteRequest = deleteStore.delete(initialData.id);
                      
                      deleteRequest.onsuccess = () => {
                        log('widgetData', 'Test data cleaned up successfully.');
                        db.close();
                        log('widgetData', 'Widget data refresh test passed!', 'success');
                      };
                    };
                  };
                } else {
                  log('widgetData', 'Data not found during refresh!', 'failure');
                  db.close();
                }
              };
            }, 2000); // Wait 2 seconds before refreshing
          };
        };
        
        dbRequest.onerror = (event) => {
          log('widgetData', 'Error opening IndexedDB: ' + event.target.error.message, 'failure');
        };
      } catch (error) {
        log('widgetData', `Error: ${error.message}`, 'failure');
      }
    });

    // ===========================
    // 5. Integration Tests
    // ===========================
    
    // Test widget lifecycle
    document.getElementById('testWidgetLifecycle').addEventListener('click', () => {
      clearLog('integration');
      log('integration', 'Testing widget lifecycle...');

      try {
        log('integration', 'Starting widget lifecycle test...');
        
        // Step 1: Register widget type
        log('integration', '1. Registering widget type...');
        const clockWidgetType = {
          type: 'clock',
          name: 'Clock Widget',
          description: 'Displays current time and date',
          defaultConfig: {
            type: 'clock',
            title: 'Clock',
            visible: true,
            position: { x: 0, y: 0, width: 2, height: 1 },
            appearance: { showTitle: true },
            clockSettings: {
              showSeconds: true,
              showDate: true,
              use24HourFormat: false,
            }
          }
        };
        
        // Save widget type to registry
        const registryKey = 'lifecycle-test-registry';
        localStorage.setItem(registryKey, JSON.stringify({
          version: 1,
          data: {
            types: [clockWidgetType],
            instances: []
          },
          timestamp: Date.now()
        }));
        
        // Step 2: Create widget instance
        log('integration', '2. Creating widget instance...');
        const registry = JSON.parse(localStorage.getItem(registryKey));
        
        const widgetId = generateId();
        const clockInstance = {
          ...JSON.parse(JSON.stringify(clockWidgetType.defaultConfig)),
          id: widgetId,
          title: 'My Clock Widget',
          position: { x: 1, y: 2, width: 3, height: 1 }
        };
        
        registry.data.instances = [clockInstance];
        localStorage.setItem(registryKey, JSON.stringify(registry));
        
        log('integration', `Widget instance created with ID: ${widgetId}`);
        
        // Step 3: Set widget data
        log('integration', '3. Setting widget data...');
        
        // Use IndexedDB for widget data
        const dbRequest = indexedDB.open('lifecycle-test-db', 1);
        
        dbRequest.onupgradeneeded = (event) => {
          const db = event.target.result;
          
          if (!db.objectStoreNames.contains('data')) {
            const objectStore = db.createObjectStore('data', { keyPath: 'id' });
            objectStore.createIndex('widgetId', 'widgetId', { unique: false });
          }
        };
        
        dbRequest.onsuccess = (event) => {
          const db = event.target.result;
          
          const clockData = {
            id: `widget_data_${widgetId}`,
            widgetId: widgetId,
            type: 'clock',
            data: {
              time: new Date().toISOString(),
              timezone: 'Europe/Oslo'
            },
            updatedAt: Date.now()
          };
          
          const transaction = db.transaction(['data'], 'readwrite');
          const objectStore = transaction.objectStore('data');
          const addRequest = objectStore.add(clockData);
          
          addRequest.onsuccess = () => {
            log('integration', 'Widget data set successfully.');
            
            // Step 4: Update widget configuration
            log('integration', '4. Updating widget configuration...');
            const updatedRegistry = JSON.parse(localStorage.getItem(registryKey));
            const widgetInstance = updatedRegistry.data.instances.find(w => w.id === widgetId);
            
            if (widgetInstance) {
              widgetInstance.title = 'Updated Clock Widget';
              widgetInstance.clockSettings.showSeconds = false;
              widgetInstance.clockSettings.use24HourFormat = true;
              
              localStorage.setItem(registryKey, JSON.stringify(updatedRegistry));
              log('integration', 'Widget configuration updated successfully.');
              
              // Step 5: Update widget data
              log('integration', '5. Updating widget data...');
              const dataTransaction = db.transaction(['data'], 'readwrite');
              const dataStore = dataTransaction.objectStore('data');
              const getRequest = dataStore.get(clockData.id);
              
              getRequest.onsuccess = () => {
                const currentData = getRequest.result;
                
                if (currentData) {
                  currentData.data.time = new Date().toISOString();
                  currentData.updatedAt = Date.now();
                  
                  const updateRequest = dataStore.put(currentData);
                  
                  updateRequest.onsuccess = () => {
                    log('integration', 'Widget data updated successfully.');
                    
                    // Step 6: Delete widget
                    log('integration', '6. Deleting widget...');
                    const finalRegistry = JSON.parse(localStorage.getItem(registryKey));
                    finalRegistry.data.instances = finalRegistry.data.instances.filter(w => w.id !== widgetId);
                    
                    localStorage.setItem(registryKey, JSON.stringify(finalRegistry));
                    
                    const deleteTransaction = db.transaction(['data'], 'readwrite');
                    const deleteStore = deleteTransaction.objectStore('data');
                    const deleteRequest = deleteStore.delete(clockData.id);
                    
                    deleteRequest.onsuccess = () => {
                      log('integration', 'Widget and its data deleted successfully.');
                      
                      // Clean up
                      localStorage.removeItem(registryKey);
                      db.close();
                      log('integration', 'Widget lifecycle test passed!', 'success');
                    };
                  };
                } else {
                  log('integration', 'Widget data not found during update!', 'failure');
                  db.close();
                }
              };
            } else {
              log('integration', 'Widget instance not found!', 'failure');
              db.close();
            }
          };
        };
        
        dbRequest.onerror = (event) => {
          log('integration', 'Error opening IndexedDB: ' + event.target.error.message, 'failure');
        };
      } catch (error) {
        log('integration', `Error: ${error.message}`, 'failure');
      }
    });
    
    // Test state persistence
    document.getElementById('testPersistence').addEventListener('click', () => {
      clearLog('integration');
      log('integration', 'Testing state persistence across page reloads...');

      try {
        // Create a marker to detect page reloads
        const persistenceTest = localStorage.getItem('persistence-test-marker');
        
        if (persistenceTest) {
          // This is after a reload
          log('integration', 'Page reloaded! Testing state recovery...');
          
          // Check all the states we saved before reload
          const settings = JSON.parse(localStorage.getItem('persistence-settings'));
          const layout = JSON.parse(localStorage.getItem('persistence-layout'));
          const theme = JSON.parse(localStorage.getItem('persistence-theme'));
          const widgets = JSON.parse(localStorage.getItem('persistence-widgets'));
          
          if (settings && layout && theme && widgets) {
            log('integration', 'All state data recovered successfully.');
            log('integration', 'Recovered settings: ' + settings.general.appName);
            log('integration', 'Recovered layout: ' + layout.grid.columns + 'Ã—' + layout.grid.rows);
            log('integration', 'Recovered theme: ' + theme.colorMode);
            log('integration', 'Recovered widgets: ' + widgets.instances.length);
            
            // Clean up
            localStorage.removeItem('persistence-test-marker');
            localStorage.removeItem('persistence-settings');
            localStorage.removeItem('persistence-layout');
            localStorage.removeItem('persistence-theme');
            localStorage.removeItem('persistence-widgets');
            
            log('integration', 'State persistence test passed!', 'success');
          } else {
            log('integration', 'Failed to recover all state data!', 'failure');
          }
        } else {
          // First run - save state and reload
          log('integration', 'Setting up state persistence test...');
          
          // Create test states
          const settings = {
            general: {
              appName: 'Persistence Test App',
              language: 'en',
              timezone: 'Europe/Oslo'
            },
            display: {
              fullscreen: true,
              theme: 'dark'
            }
          };
          
          const layout = {
            grid: {
              columns: 6,
              rows: 4
            },
            widgets: [
              { id: 'w1', x: 0, y: 0, width: 2, height: 1 },
              { id: 'w2', x: 2, y: 0, width: 4, height: 2 }
            ]
          };
          
          const theme = {
            colorMode: 'dark',
            primaryColor: 'blue.500',
            fontSize: 16
          };
          
          const widgets = {
            types: [
              { type: 'clock', name: 'Clock' },
              { type: 'weather', name: 'Weather' }
            ],
            instances: [
              { id: 'w1', type: 'clock', title: 'My Clock' },
              { id: 'w2', type: 'weather', title: 'My Weather' }
            ]
          };
          
          // Save states
          localStorage.setItem('persistence-settings', JSON.stringify(settings));
          localStorage.setItem('persistence-layout', JSON.stringify(layout));
          localStorage.setItem('persistence-theme', JSON.stringify(theme));
          localStorage.setItem('persistence-widgets', JSON.stringify(widgets));
          
          // Set marker for reload detection
          localStorage.setItem('persistence-test-marker', 'true');
          
          log('integration', 'State data saved. Simulating page reload...');
          log('integration', 'This will clear all logs. Please run this test again to verify persistence.', 'warning');
          
          // Simulate reload by clearing all logs
          setTimeout(() => {
            document.querySelectorAll('pre').forEach(el => el.innerHTML = '');
            document.querySelectorAll('.result').forEach(el => {
              el.textContent = '';
              el.className = 'result';
            });
            
            log('integration', 'Page "reloaded". Run this test again to check persistence.', 'warning');
          }, 2000);
        }
      } catch (error) {
        log('integration', `Error: ${error.message}`, 'failure');
      }
    });
    
    // Test complete system
    document.getElementById('testCompleteSystem').addEventListener('click', () => {
      clearLog('integration');
      log('integration', 'Testing complete state management system...');

      try {
        log('integration', 'Starting comprehensive system test...');
        
        // Step 1: Set app settings
        log('integration', '1. Setting app settings...');
        const settings = {
          general: {
            appName: 'System Test App',
            language: 'en',
            timezone: 'Europe/Oslo',
            autoSave: true,
            autoRefresh: true,
            refreshInterval: 60000
          },
          display: {
            fullscreen: false,
            showClock: true,
            showControls: true,
            controlsPosition: 'bottom',
            screenSaver: {
              enabled: true,
              timeout: 300000,
              type: 'photos'
            }
          },
          network: {
            offlineMode: false,
            cacheStrategy: 'network-first'
          },
          advanced: {
            debugMode: true
          }
        };
        
        localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify({
          version: 1,
          data: settings,
          timestamp: Date.now()
        }));
        
        // Step 2: Set theme
        log('integration', '2. Setting theme configuration...');
        const theme = {
          colorMode: 'dark',
          primaryColor: 'purple.500',
          backgroundColor: 'gray.900',
          textColor: 'white',
          accentColor: 'teal.400',
          fontSizeBase: 16,
          highContrast: false
        };
        
        localStorage.setItem(STORAGE_KEYS.THEME_CONFIG, JSON.stringify({
          version: 1,
          data: theme,
          timestamp: Date.now()
        }));
        
        // Step 3: Set layout
        log('integration', '3. Setting layout configuration...');
        const layout = {
          grid: {
            columns: 12,
            rows: 12
          },
          widgets: [
            { id: 'w1', x: 0, y: 0, width: 4, height: 3, visible: true },
            { id: 'w2', x: 4, y: 0, width: 8, height: 3, visible: true },
            { id: 'w3', x: 0, y: 3, width: 6, height: 4, visible: true },
            { id: 'w4', x: 6, y: 3, width: 6, height: 4, visible: true }
          ]
        };
        
        localStorage.setItem(STORAGE_KEYS.LAYOUT_CONFIG, JSON.stringify({
          version: 1,
          data: layout,
          timestamp: Date.now()
        }));
        
        // Step 4: Create widget registry
        log('integration', '4. Setting up widget registry...');
        const registry = {
          types: [
            {
              type: 'clock',
              name: 'Clock Widget',
              description: 'Displays current time and date',
              defaultConfig: {
                type: 'clock',
                title: 'Clock',
                visible: true,
                position: { x: 0, y: 0, width: 2, height: 1 },
                appearance: { showTitle: true },
                clockSettings: {
                  showSeconds: true,
                  showDate: true,
                  use24HourFormat: false,
                }
              }
            },
            {
              type: 'weather',
              name: 'Weather Widget',
              description: 'Displays weather information',
              defaultConfig: {
                type: 'weather',
                title: 'Weather',
                visible: true,
                position: { x: 0, y: 0, width: 2, height: 2 },
                appearance: { showTitle: true },
                weatherSettings: {
                  location: 'Oslo, Norway',
                  units: 'metric',
                  showForecast: true
                }
              }
            },
            {
              type: 'calendar',
              name: 'Calendar Widget',
              description: 'Displays calendar events',
              defaultConfig: {
                type: 'calendar',
                title: 'Calendar',
                visible: true,
                position: { x: 0, y: 0, width: 3, height: 2 },
                appearance: { showTitle: true },
                calendarSettings: {
                  showWeekNumbers: true,
                  calendars: ['primary'],
                  daysToShow: 7
                }
              }
            },
            {
              type: 'photo',
              name: 'Photo Widget',
              description: 'Displays photos',
              defaultConfig: {
                type: 'photo',
                title: 'Photos',
                visible: true,
                position: { x: 0, y: 0, width: 3, height: 3 },
                appearance: { showTitle: false },
                photoSettings: {
                  sources: ['default'],
                  interval: 30000,
                  transition: 'fade'
                }
              }
            }
          ],
          instances: [
            {
              id: 'w1',
              type: 'clock',
              title: 'System Clock',
              visible: true,
              position: { x: 0, y: 0, width: 4, height: 3 },
              appearance: { showTitle: true, backgroundColor: 'transparent' },
              clockSettings: {
                showSeconds: true,
                showDate: true,
                use24HourFormat: true,
                timezone: 'Europe/Oslo'
              }
            },
            {
              id: 'w2',
              type: 'weather',
              title: 'Oslo Weather',
              visible: true,
              position: { x: 4, y: 0, width: 8, height: 3 },
              appearance: { showTitle: true, backgroundColor: 'transparent' },
              weatherSettings: {
                location: 'Oslo, Norway',
                units: 'metric',
                showForecast: true,
                forecastDays: 5,
                showHourlyForecast: true
              }
            },
            {
              id: 'w3',
              type: 'calendar',
              title: 'My Calendar',
              visible: true,
              position: { x: 0, y: 3, width: 6, height: 4 },
              appearance: { showTitle: true, backgroundColor: 'transparent' },
              calendarSettings: {
                showWeekNumbers: true,
                calendars: ['primary', 'work'],
                daysToShow: 7,
                showAllDayEvents: true
              }
            },
            {
              id: 'w4',
              type: 'photo',
              title: 'Photo Gallery',
              visible: true,
              position: { x: 6, y: 3, width: 6, height: 4 },
              appearance: { showTitle: false, backgroundColor: 'black' },
              photoSettings: {
                sources: ['vacation2023', 'family'],
                interval: 15000,
                transition: 'fade',
                showCaption: true
              }
            }
          ]
        };
        
        localStorage.setItem(STORAGE_KEYS.WIDGETS, JSON.stringify({
          version: 1,
          data: registry,
          timestamp: Date.now()
        }));
        
        // Step 5: Set up IndexedDB for widget data
        log('integration', '5. Setting up IndexedDB for widget data...');
        
        const dbRequest = indexedDB.open('system-test-db', 1);
        
        dbRequest.onupgradeneeded = (event) => {
          const db = event.target.result;
          
          if (!db.objectStoreNames.contains('data')) {
            const objectStore = db.createObjectStore('data', { keyPath: 'id' });
            objectStore.createIndex('widgetId', 'widgetId', { unique: false });
            objectStore.createIndex('type', 'type', { unique: false });
          }
        };
        
        dbRequest.onsuccess = (event) => {
          const db = event.target.result;
          log('integration', 'Database opened successfully.');
          
          // Add data for all widgets
          const transaction = db.transaction(['data'], 'readwrite');
          const objectStore = transaction.objectStore('data');
          
          const widgetData = [
            {
              id: 'widget_data_w1',
              widgetId: 'w1',
              type: 'clock',
              data: {
                time: new Date().toISOString(),
                timezone: 'Europe/Oslo'
              },
              updatedAt: Date.now()
            },
            {
              id: 'widget_data_w2',
              widgetId: 'w2',
              type: 'weather',
              data: {
                current: {
                  temperature: 18,
                  condition: 'Partly Cloudy',
                  humidity: 65,
                  windSpeed: 5
                },
                forecast: [
                  { day: 'Today', high: 20, low: 15, condition: 'Partly Cloudy' },
                  { day: 'Tomorrow', high: 22, low: 14, condition: 'Sunny' }
                ],
                location: {
                  name: 'Oslo',
                  country: 'Norway'
                }
              },
              updatedAt: Date.now()
            },
            {
              id: 'widget_data_w3',
              widgetId: 'w3',
              type: 'calendar',
              data: {
                events: [
                  { 
                    id: 'evt1', 
                    title: 'Team Meeting', 
                    start: new Date(Date.now() + 3600000).toISOString(),
                    end: new Date(Date.now() + 7200000).toISOString(),
                    calendar: 'work'
                  },
                  { 
                    id: 'evt2', 
                    title: 'Lunch with Sarah', 
                    start: new Date(Date.now() + 86400000).toISOString(),
                    end: new Date(Date.now() + 90000000).toISOString(),
                    calendar: 'primary'
                  }
                ]
              },
              updatedAt: Date.now()
            },
            {
              id: 'widget_data_w4',
              widgetId: 'w4',
              type: 'photo',
              data: {
                photos: [
                  { url: 'photo1.jpg', caption: 'Summer vacation', date: '2023-07-15' },
                  { url: 'photo2.jpg', caption: 'Family gathering', date: '2023-08-22' },
                  { url: 'photo3.jpg', caption: 'Mountain hike', date: '2023-09-03' }
                ],
                currentIndex: 0
              },
              updatedAt: Date.now()
            }
          ];
          
          let completed = 0;
          
          widgetData.forEach(data => {
            const addRequest = objectStore.add(data);
            
            addRequest.onsuccess = () => {
              completed++;
              if (completed === widgetData.length) {
                log('integration', 'All widget data added successfully.');
                
                // Step 6: Verify entire system state
                log('integration', '6. Verifying system state...');
                
                // Check settings
                const storedSettings = JSON.parse(localStorage.getItem(STORAGE_KEYS.SETTINGS));
                // Check theme
                const storedTheme = JSON.parse(localStorage.getItem(STORAGE_KEYS.THEME_CONFIG));
                // Check layout
                const storedLayout = JSON.parse(localStorage.getItem(STORAGE_KEYS.LAYOUT_CONFIG));
                // Check widgets
                const storedWidgets = JSON.parse(localStorage.getItem(STORAGE_KEYS.WIDGETS));
                
                if (storedSettings && storedTheme && storedLayout && storedWidgets) {
                  log('integration', 'All configuration verified in localStorage.');
                  
                  // Check IndexedDB
                  const dataTransaction = db.transaction(['data'], 'readonly');
                  const dataStore = dataTransaction.objectStore('data');
                  const getRequest = dataStore.getAll();
                  
                  getRequest.onsuccess = () => {
                    const allData = getRequest.result;
                    
                    if (allData && allData.length === widgetData.length) {
                      log('integration', `All widget data verified in IndexedDB: ${allData.length} items.`);
                      
                      // Clean up
                      log('integration', '7. Cleaning up test data...');
                      localStorage.removeItem(STORAGE_KEYS.SETTINGS);
                      localStorage.removeItem(STORAGE_KEYS.THEME_CONFIG);
                      localStorage.removeItem(STORAGE_KEYS.LAYOUT_CONFIG);
                      localStorage.removeItem(STORAGE_KEYS.WIDGETS);
                      
                      const deleteTransaction = db.transaction(['data'], 'readwrite');
                      const deleteStore = deleteTransaction.objectStore('data');
                      const clearRequest = deleteStore.clear();
                      
                      clearRequest.onsuccess = () => {
                        log('integration', 'All test data cleaned up successfully.');
                        db.close();
                        
                        // Done!
                        log('integration', 'Complete system test passed!', 'success');
                      };
                    } else {
                      log('integration', `Widget data verification failed. Expected ${widgetData.length}, got ${allData ? allData.length : 0}.`, 'failure');
                      db.close();
                    }
                  };
                } else {
                  log('integration', 'Configuration verification failed.', 'failure');
                  db.close();
                }
              }
            };
            
            addRequest.onerror = (event) => {
              log('integration', 'Error adding widget data: ' + event.target.error.message, 'failure');
              db.close();
            };
          });
        };
        
        dbRequest.onerror = (event) => {
          log('integration', 'Error opening IndexedDB: ' + event.target.error.message, 'failure');
        };
      } catch (error) {
        log('integration', `Error: ${error.message}`, 'failure');
      }
    });
  </script>
</body>
</html>